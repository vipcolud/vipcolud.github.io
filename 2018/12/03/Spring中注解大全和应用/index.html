
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BELONG&#39;s Blog</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="belongapp,"> 
    <meta name="description" content="专注于后端开发,"> 
    <meta name="author" content="BELONG"> 
    <link rel="alternative" href="atom.xml" title="BELONG&#39;s Blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2c17dd32817c94173b19c2a392bb97e9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();

 (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "{{theme.daovoice_app_id}}"
    });
  daovoice('update');


</script>


</head>

<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">Spring中注解大全和应用</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Spring中注解大全和应用</h1>
        <div class="stuff">
            <span>十二月 03, 2018</span>
            

            <span id="busuanzi_container_page_pv">
   本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
        </div>
        <div class="content markdown">
            <p>@Controller</p>
<p>标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">public class TestController &#123;</div><div class="line">        @RequestMapping(&quot;/test&quot;)</div><div class="line">        public String test(Map&lt;String,Object&gt; map)&#123;</div><div class="line"></div><div class="line">            return &quot;hello&quot;;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@RestController</p>
<p>Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">public class TestController &#123;</div><div class="line">        @RequestMapping(&quot;/test&quot;)</div><div class="line">        public String test(Map&lt;String,Object&gt; map)&#123;</div><div class="line"></div><div class="line">            return &quot;hello&quot;;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@Service</p>
<p>用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中</p>
<p>@Autowired</p>
<p>用来装配bean，都可以写在字段上，或者方法上。<br>默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false)</p>
<p>@RequestMapping</p>
<p>类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。<br>方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。</p>
<p>用过RequestMapping的同学都知道，他有非常多的作用，因此详细的用法<br>我会在下一篇文章专门讲述，请关注公众号哦，以免错过。</p>
<p>@RequestParam</p>
<p>用于将请求参数区数据映射到功能处理方法的参数上<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Resp test(@RequestParam Integer id)&#123;</div><div class="line">        return Resp.success(customerInfoService.fetch(id));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个id就是要接收从接口传递过来的参数id的值的，如果接口传递过来的参数名和你接收的不一致，也可以如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Resp test(@RequestParam(value=&quot;course_id&quot;) Integer id)&#123;</div><div class="line">        return Resp.success(customerInfoService.fetch(id));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中course_id就是接口传递的参数，id就是映射course_id的参数名</p>
<p>@ModelAttribute</p>
<p>使用地方有三种：</p>
<ol>
<li>标记在方法上。</li>
</ol>
<p>标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。</p>
<p>A.在有返回的方法上:</p>
<p>当ModelAttribute设置了value，方法返回的值会以这个value为key，以参数接受到的值作为value，存入到Model中，如下面的方法执行之后，最终相当于 model.addAttribute(“user_name”, name);假如 @ModelAttribute没有自定义value，则相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">model.addAttribute(&quot;name&quot;, name);</div><div class="line"></div><div class="line">@ModelAttribute(value=&quot;user_name&quot;)</div><div class="line">    public String before2(@RequestParam(required = false) String name, Model model) &#123;</div><div class="line">       System.out.println(&quot;进入了2：&quot; + name);</div><div class="line">       return name;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>B.在没返回的方法上：</p>
<p>需要手动model.add方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    @ModelAttribute</div><div class="line">    public void before(@RequestParam(required = false) Integer age, Model model) &#123;</div><div class="line">        model.addAttribute(&quot;age&quot;, age);</div><div class="line">        System.out.println(&quot;进入了1：&quot; + age);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们在当前类下建一个请求方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/mod&quot;)</div><div class="line">    public Resp mod(</div><div class="line">            @RequestParam(required = false) String name,</div><div class="line">            @RequestParam(required = false) Integer age, </div><div class="line">            Model model)&#123;</div><div class="line">        System.out.println(&quot;进入mod&quot;);</div><div class="line">        System.out.println(&quot;参数接受的数值&#123;name=&quot;+name+&quot;;age=&quot;+age+&quot;&#125;&quot;);</div><div class="line">        System.out.println(&quot;model传过来的值:&quot;+model);</div><div class="line">        return Resp.success(&quot;1&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在浏览器中输入访问地址并且加上参数：<br><a href="http://localhost:8081/api/test/mod?name=我是小菜&amp;age=12" target="_blank" rel="external">http://localhost:8081/api/test/mod?name=我是小菜&amp;age=12</a></p>
<p>最终输出如下：</p>
<p>1进入了1：40<br>2进入了2：我是小菜<br>3进入mod<br>4参数接受的数值{name=我是小菜;age=12}<br>5model传过来的值:{age=40, user_name=我是小菜}</p>
<ol>
<li>标记在方法的参数上。</li>
</ol>
<p>标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用.<br>我们在上面的类中加入一个方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/mod2&quot;)</div><div class="line">    public Resp mod2(@ModelAttribute(&quot;user_name&quot;) String user_name, </div><div class="line">           @ModelAttribute(&quot;name&quot;) String name,</div><div class="line">            @ModelAttribute(&quot;age&quot;) Integer age,Model model)&#123;</div><div class="line">        System.out.println(&quot;进入mod2&quot;);</div><div class="line">       System.out.println(&quot;user_name:&quot;+user_name);</div><div class="line">        System.out.println(&quot;name：&quot;+name);</div><div class="line">       System.out.println(&quot;age:&quot;+age);</div><div class="line">       System.out.println(&quot;model:&quot;+model);</div><div class="line">        return Resp.success(&quot;1&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在浏览器中输入访问地址并且加上参数：<br><a href="http://localhost:8081/api/test/mod2?name=我是小菜&amp;age=12" target="_blank" rel="external">http://localhost:8081/api/test/mod2?name=我是小菜&amp;age=12</a><br>最终输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1进入了1：40</div><div class="line">2进入了2：我是小菜</div><div class="line">3进入mod2</div><div class="line">4user_name:我是小菜</div><div class="line">5name：我是小菜</div><div class="line">6age:40</div><div class="line">7model:&#123;user_name=我是小菜, org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, age=40, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: 0 errors&#125;</div><div class="line">从结果就能看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。</div></pre></td></tr></table></figure>
<p>@Cacheable</p>
<p>用来标记缓存查询。可用用于方法或者类中，</p>
<p>当标记在一个方法上时表示该方法是支持缓存的，<br>当标记在一个类上时则表示该类所有的方法都是支持缓存的。</p>
<p>参数列表</p>
<p>参数  解释  例子<br>value   名称  @Cacheable(value={”c1”,”c2”}<br>key key @Cacheable(value=”c1”,key=”#id”)<br>condition   条件  @Cacheable(value=”c1”,condition=”#id=1”)<br>比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。<br>但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Cacheable(value=&quot;UserCache&quot;)// 使用了一个缓存名叫 accountCache   </div><div class="line">public Account getUserAge(int id) &#123;  </div><div class="line">     //这里不用写缓存的逻辑，直接按正常业务逻辑走即可，</div><div class="line">     //缓存通过切面自动切入  </div><div class="line">    int age=getUser(id);   </div><div class="line">    return age;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@CacheEvict</p>
<p>用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。@CacheEvict(value=”UserCache”)</p>
<p>参数列表</p>
<p>参数  解释  例子<br>value   名称  @CachEvict(value={”c1”,”c2”}<br>key key @CachEvict(value=”c1”,key=”#id”)<br>condition   缓存的条件，可以为空<br>allEntries  是否清空所有缓存内容  @CachEvict(value=”c1”，allEntries=true)<br>beforeInvocation    是否在方法执行前就清空 @CachEvict(value=”c1”，beforeInvocation=true)<br>@Resource</p>
<p>@Resource的作用相当于@Autowired<br>只不过@Autowired按byType自动注入，<br>而@Resource默认按 byName自动注入罢了。</p>
<p>@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<p>@Resource装配顺序:</p>
<p>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</p>
<p>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</p>
<p>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</p>
<p>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</p>
<p>@PostConstruct</p>
<p>用来标记是在项目启动的时候执行这个方法。用来修饰一个非静态的void()方法<br>也就是spring容器启动时就执行，多用于一些全局配置、数据字典之类的加载</p>
<p>被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行,init()方法之前执行。PreDestroy（）方法在destroy()方法执行执行之后执</p>
<p>@PreDestroy</p>
<p>被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前</p>
<p>@Repository</p>
<p>用于标注数据访问组件，即DAO组件</p>
<p>@Component</p>
<p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p>
<p>@Scope</p>
<p>用来配置 spring bean 的作用域，它标识 bean 的作用域。<br>默认值是单例</p>
<p>singleton:单例模式,全局有且仅有一个实例</p>
<p>prototype:原型模式,每次获取Bean的时候会有一个新的实例</p>
<p>request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</p>
<p>session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效</p>
<p>global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。</p>
<p>@SessionAttributes</p>
<p>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中</p>
<p>参数：</p>
<p>names：这是一个字符串数组。里面应写需要存储到session中数据的名称。</p>
<p>types：根据指定参数的类型，将模型中对应类型的参数存储到session中</p>
<p>value：和names是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> @Controller</div><div class="line"> @SessionAttributes(value=&#123;&quot;names&quot;&#125;,types=&#123;Integer.class&#125;)</div><div class="line"> public class ScopeService &#123;</div><div class="line">         @RequestMapping(&quot;/testSession&quot;)</div><div class="line">        public String test(Map&lt;String,Object&gt; map)&#123;</div><div class="line">             map.put(&quot;names&quot;, Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));</div><div class="line">            map.put(&quot;age&quot;, 12);</div><div class="line">            return &quot;hello&quot;;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@Required</p>
<p>适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。</p>
<p>@Qualifier</p>
<p>当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="https://music.163.com/#/song?id=299258">
            </audio>
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='c27524ff7fa274a5f47a'
        data-cs='9ca2b17a9a49906b5f3ee758825c4d45a7e4ece4'
        data-r='vipcolud.github.io'
        data-o='vipcolud'
        data-a='vipcolud'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69833742-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>